@file:Suppress("RedundantSuppression", "ClassName", "RedundantVisibilityModifier")

package com.afollestad.ulfberht

import com.afollestad.ulfberht.test.Snippets
import com.afollestad.ulfberht.test.TestKotlinCompiler
import com.afollestad.ulfberht.test.assertGeneratedSourceEquals
import com.tschuchort.compiletesting.KotlinCompilation.ExitCode.COMPILATION_ERROR
import com.tschuchort.compiletesting.SourceFile
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class UlfberhtProcessorFactoryBindsToTest {

  @Rule
  @JvmField
  var temporaryFolder: TemporaryFolder = TemporaryFolder()

  private val compiler = TestKotlinCompiler(temporaryFolder)

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there are no parameters or qualifier`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient : Client {
          override fun doSomething() = Unit
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory : Factory<Client> {
          public override fun create(): Client = RealClient()
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a qualifier but no parameters`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        
        interface Client {
          fun doSomething()
        }

        @TestQualifier
        @BindsTo(AppScope::class)
        class RealClient : Client {
          override fun doSomething() = Unit
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_TestQualifier_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_TestQualifier_Factory : Factory<Client> {
          @TestQualifier
          public override fun create(): Client = RealClient()
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a unqualified Factory parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Inject
        
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          val authTokens: AuthTokens,
        ) : Client {
          override fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          private val authTokensFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            authTokens = authTokensFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a qualified Factory parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Inject
        
        @TestQualifier
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          @TestQualifier val authTokens: AuthTokens,
        ) : Client {
          override fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          @TestQualifier
          private val authTokensTestQualifierFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            authTokens = authTokensTestQualifierFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a unqualified Provider parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Provides

        data class ApiCredentials(val key: String)

        @Provides
        fun provideApiCredentials(): ApiCredentials = ApiCredentials("fake-api-key")

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          val apiCredentials: ApiCredentials,
        ) : Client {
          override fun doSomething() {
            println(apiCredentials.key)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          private val apiCredentialsProvider: Provider<ApiCredentials>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            apiCredentials = apiCredentialsProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a qualified Provider parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Provides
        import com.afollestad.ulfberht.annotation.Qualifier
        
        @Qualifier
        interface AuthToken

        @AuthToken
        @Provides
        fun provideAuthToken(): String = "fake-auth-token"

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          @AuthToken val authToken: String,
        ) : Client {
          override fun doSomething() {
            println(authToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        import kotlin.String
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          @AuthToken
          private val stringAuthTokenProvider: Provider<String>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            authToken = stringAuthTokenProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a unqualified Factory parameter with dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Provides
        
        data class ApiCredentials(val key: String)
    
        @Provides fun provideApiCredentials(): ApiCredentials = ApiCredentials("fake-api-key")

        class LoginService @Inject constructor(
          val apiCredentials: ApiCredentials,
        ) {
          fun fetchToken(): String = "token-using-key-$\{apiCredentials.key\}"
        }

        class AuthTokens @Inject constructor(
          private val loginService: LoginService,
        ) {
          val currentToken: String get() = loginService.fetchToken()
        }

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          val authTokens: AuthTokens,
        ) : Client {
          override fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          private val authTokensFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            authTokens = authTokensFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a qualified Factory parameter with dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Provides
                
        data class ApiCredentials(val key: String)
    
        @Provides fun provideApiCredentials(): ApiCredentials = ApiCredentials("fake-api-key")

        class LoginService @Inject constructor(
          val apiCredentials: ApiCredentials,
        ) {
          fun fetchToken(): String = "token-using-key-$\{apiCredentials.key\}"
        }

        @TestQualifier
        class AuthTokens @Inject constructor(
          private val loginService: LoginService,
        ) {
          val currentToken: String get() = loginService.fetchToken()
        }

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          @TestQualifier val authTokens: AuthTokens,
        ) : Client {
          override fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          @TestQualifier
          private val authTokensTestQualifierFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            authTokens = authTokensTestQualifierFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a unqualified Provider parameter with dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Provides

        data class Token(val value: String)

        class TokensService @Inject constructor() {
          fun fetchToken(): Token = Token("hello, world!")
        }

        @Provides
        fun provideToken(service: TokensService): Token = service.fetchToken()

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(val token: Token) : Client {
          override fun doSomething() { println(token) }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          private val tokenProvider: Provider<Token>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            token = tokenProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class annotated with @BindsTo generates a Factory when there is a qualified Provider parameter with dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.AppScope,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Provides
        import com.afollestad.ulfberht.annotation.Qualifier

        class TokensService @Inject constructor() {
          fun fetchToken(): String = "hello, world!"
        }

        @Qualifier
        interface Token

        @Provides @Token
        fun provideToken(service: TokensService): String = service.fetchToken()

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(@Token val token: String) : Client {
          override fun doSomething() { println(token) }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "RealClient_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        import kotlin.String
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class RealClient_Factory(
          @Token
          private val stringTokenProvider: Provider<String>,
        ) : Factory<Client> {
          public override fun create(): Client = RealClient(
            token = stringTokenProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `compilation fails if a class annotated with @BindsTo has a parameter without a matching or similar binding`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Inject
        
        // No @Inject or @BindsTo - no binding exists.
        class AuthTokens {
          val currentToken: String = "fake-auth-token"
        }

        interface Client {
          fun doSomething()
        }

        @BindsTo(AppScope::class)
        class RealClient(
          val authTokens: AuthTokens,
        ) : Client {
          override fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    assertEquals(COMPILATION_ERROR, compilationResult.exitCode)
    val expectedMessage = "No matching binding for Key(type=com.tests.ulfberht.AuthTokens, qualifier=null)."
    assertTrue(
      "Expected compilation error containing \"$expectedMessage\" but got: ${compilationResult.messages}",
    ) {
      compilationResult.messages.contains(expectedMessage)
    }
  }

  @Test
  fun `compilation fails if a class annotated with @BindsTo has a parameter without a matching binding but has candidates`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo
        import com.afollestad.ulfberht.annotation.Inject
                
        @TestQualifier
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }
        
        interface Client {
          fun doSomething()
        }
        
        @BindsTo(AppScope::class)
        class RealClient(
          // Injected without the qualifier, so bindings don't match.
          val authTokens: AuthTokens,
        ) : Client {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    assertEquals(COMPILATION_ERROR, compilationResult.exitCode)
    val expectedMessage = "e: [ksp] No matching binding for Key(type=com.tests.ulfberht.AuthTokens, qualifier=null)." +
      " Possible candidates: [Key(type=com.tests.ulfberht.AuthTokens, qualifier=com.tests.ulfberht.TestQualifier)]"
    assertTrue(
      "Expected message containing text \"$expectedMessage\" but got: ${compilationResult.messages}",
    ) {
      compilationResult.messages.contains(expectedMessage)
    }
  }

  @Test
  fun `compilation fails if an interface is annotated with @BindsTo`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.BindsTo

        @BindsTo(AppScope::class)
        interface Client {
          fun doSomething()
        }
        """,
      ),
    )
    assertEquals(COMPILATION_ERROR, compilationResult.exitCode)
    val expectedMessage = "e: [ksp] @BindsTo is only allowed on classes."
    assertTrue(
      "Expected message containing text \"$expectedMessage\" but got: ${compilationResult.messages}",
    ) {
      compilationResult.messages.contains(expectedMessage)
    }
  }
}
