@file:Suppress("RedundantSuppression", "ClassName", "RedundantVisibilityModifier")

package com.afollestad.ulfberht

import com.afollestad.ulfberht.test.Snippets
import com.afollestad.ulfberht.test.TestKotlinCompiler
import com.afollestad.ulfberht.test.assertGeneratedSourceEquals
import com.tschuchort.compiletesting.KotlinCompilation.ExitCode.COMPILATION_ERROR
import com.tschuchort.compiletesting.SourceFile
import org.junit.Rule
import org.junit.Test
import org.junit.rules.TemporaryFolder
import kotlin.test.assertEquals
import kotlin.test.assertTrue

class UlfberhtProcessorFactoryInjectTest {

  @Rule
  @JvmField
  var temporaryFolder: TemporaryFolder = TemporaryFolder()

  private val compiler = TestKotlinCompiler(temporaryFolder)

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there are no parameters or qualifier`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject

        class Client @Inject constructor() {
          fun doSomething() = Unit
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory

        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory : Factory<Client> {
          public override fun create(): Client = Client()

          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a qualifier but no parameters`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        
        @TestQualifier
        class Client @Inject constructor() {
          fun doSomething() = Unit
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_TestQualifier_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_TestQualifier_Factory : Factory<Client> {
          @TestQualifier
          public override fun create(): Client = Client()
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a unqualified Factory parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }

        class Client @Inject constructor(
          val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht
        
        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          private val authTokensFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            authTokens = authTokensFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a qualified Factory parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Qualifier
        
        @TestQualifier
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }

        class Client @Inject constructor(
          @TestQualifier val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht
        
        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          @TestQualifier
          private val authTokensTestQualifierFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            authTokens = authTokensTestQualifierFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a singleton Factory parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Singleton
                
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }
        
        @Singleton
        class Client @Inject constructor(
          val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import kotlin.Unit
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          private val authTokensFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          private var cached: Client? = null
        
          public override fun create(): Client = cached ?: createNew().also { cached = it }
        
          public override fun destroy(): Unit {
            cached = null
          }
        
          private fun createNew(): Client = Client(
            authTokens = authTokensFactory.create(),
          )
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a unqualified Provider parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Provides

        data class ApiCredentials(val authToken: String)

        @Provides
        fun provideApiCredentials(): ApiCredentials = ApiCredentials("fake-auth-token")

        class Client @Inject constructor(
          val apiCredentials: ApiCredentials,
        ) {
          fun doSomething() {
            println(apiCredentials.authToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          private val apiCredentialsProvider: Provider<ApiCredentials>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            apiCredentials = apiCredentialsProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a qualified Provider parameter with no dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Provides
        import com.afollestad.ulfberht.annotation.Qualifier
        
        @Qualifier
        interface AuthToken

        @AuthToken
        @Provides
        fun provideAuthToken(): String = "fake-auth-token"

        class Client @Inject constructor(
          @AuthToken val authToken: String,
        ) {
          fun doSomething() {
            println(authToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        import kotlin.String
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          @AuthToken
          private val stringAuthTokenProvider: Provider<String>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            authToken = stringAuthTokenProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a unqualified Factory parameter with dependencies`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        
        class LoginService @Inject constructor() {
          fun fetchToken(): String = "token-from-login-service"
        }

        class AuthTokens @Inject constructor(
          private val loginService: LoginService,
        ) {
          val currentToken: String get() = loginService.fetchToken()
        }

        class Client @Inject constructor(
          val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht
        
        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          private val authTokensFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            authTokens = authTokensFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a qualified Factory parameter with dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject

        class LoginService @Inject constructor() {
          fun fetchToken(): String = "token-from-login-service"
        }
        
        @TestQualifier
        class AuthTokens @Inject constructor(
          private val loginService: LoginService,
        ) {
          val currentToken: String get() = loginService.fetchToken()
        }

        class Client @Inject constructor(
          @TestQualifier val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht
        
        import com.afollestad.ulfberht.Factory
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          @TestQualifier
          private val authTokensTestQualifierFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            authTokens = authTokensTestQualifierFactory.create(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a singleton Factory parameter with dependencies`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Singleton
        
        class LoginService @Inject constructor() {
          fun fetchToken(): String = "token-from-login-service"
        }
        
        class AuthTokens @Inject constructor(
          private val loginService: LoginService,
        ) {
          val currentToken: String get() = loginService.fetchToken()
        }
        
        @Singleton
        class Client @Inject constructor(
          val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import kotlin.Unit
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          private val authTokensFactory: Factory<AuthTokens>,
        ) : Factory<Client> {
          private var cached: Client? = null
        
          public override fun create(): Client = cached ?: createNew().also { cached = it }
        
          public override fun destroy(): Unit {
            cached = null
          }
        
          private fun createNew(): Client = Client(
            authTokens = authTokensFactory.create(),
          )
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a unqualified Provider parameter with dependencies`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Provides

        data class ApiConfiguration(
          val apiKey: String,
          val authToken: String,
        )
        
        class LoginService @Inject constructor() {
          fun fetchToken(): String = "token-from-login-service"
        }
        
        @Provides
        fun provideApiConfiguration(loginService: LoginService): ApiConfiguration = 
          ApiConfiguration(
            apiKey = "fake-auth-token",
            authToken = loginService.fetchToken(), 
          )

        class Client @Inject constructor(
          val apiConfiguration: ApiConfiguration,
        ) {
          fun doSomething() {
            println(apiConfiguration)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
      
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          private val apiConfigurationProvider: Provider<ApiConfiguration>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            apiConfiguration = apiConfigurationProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `a class with a constructor annotated with @Inject generates a Factory when there is a qualified Provider parameter with dependencies`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        import com.afollestad.ulfberht.annotation.Provides
        import com.afollestad.ulfberht.annotation.Qualifier
        
        @Qualifier
        interface AuthToken

        @AuthToken
        @Provides
        fun provideAuthToken(): String = "fake-auth-token"

        class Client @Inject constructor(
          @AuthToken val authToken: String,
        ) {
          fun doSomething() {
            println(authToken)
          }
        }
        """,
      ),
    )
    compilationResult.assertGeneratedSourceEquals(
      fileName = "Client_Factory.kt",
      expectedSource = """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.Factory
        import com.afollestad.ulfberht.Provider
        import kotlin.String
        
        /**
         * Generated by [Ulfberht](https://github.com/afollestad/ulfberht)
         */
        public class Client_Factory(
          @AuthToken
          private val stringAuthTokenProvider: Provider<String>,
        ) : Factory<Client> {
          public override fun create(): Client = Client(
            authToken = stringAuthTokenProvider.get(),
          )
        
          public override fun destroy() = Unit
        }
      """.trimIndent(),
    )
  }

  @Test
  fun `compilation fails if a class with a constructor annotated with @Inject has a parameter without a matching or similar binding`() {
    val compilationResult = compiler.compile(
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
        
        // No @Inject or @BindsTo - no binding exists.
        class AuthTokens {
          val currentToken: String = "fake-auth-token"
        }

        class Client @Inject constructor(
          val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    assertEquals(COMPILATION_ERROR, compilationResult.exitCode)
    val expectedMessage = "No matching binding for Key(type=com.tests.ulfberht.AuthTokens, qualifier=null)."
    assertTrue(
      "Expected compilation error containing \"$expectedMessage\" but got: ${compilationResult.messages}",
    ) {
      compilationResult.messages.contains(expectedMessage)
    }
  }

  @Test
  fun `compilation fails if a class with a constructor annotated with @Inject has a parameter without a matching binding but has candidates`() {
    val compilationResult = compiler.compile(
      Snippets.TestQualifier,
      SourceFile.kotlin(
        "file1.kt",
        """
        package com.tests.ulfberht

        import com.afollestad.ulfberht.annotation.Inject
                
        @TestQualifier
        class AuthTokens @Inject constructor() {
          val currentToken: String = "fake-auth-token"
        }

        class Client @Inject constructor(
          // Injected without the qualifier, so bindings don't match.
          val authTokens: AuthTokens,
        ) {
          fun doSomething() {
            println(authTokens.currentToken)
          }
        }
        """,
      ),
    )
    assertEquals(COMPILATION_ERROR, compilationResult.exitCode)
    val expectedMessage = "e: [ksp] No matching binding for Key(type=com.tests.ulfberht.AuthTokens, qualifier=null)." +
      " Possible candidates: [Key(type=com.tests.ulfberht.AuthTokens, qualifier=com.tests.ulfberht.TestQualifier)]"
    assertTrue(
      "Expected message containing text \"$expectedMessage\" but got: ${compilationResult.messages}"
    ) {
      compilationResult.messages.contains(expectedMessage)
    }
  }
}
